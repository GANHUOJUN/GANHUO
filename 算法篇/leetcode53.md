# leetcode 53. 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

## 示例：

    输入: [-2,1,-3,4,-1,2,1,-5,4],
    输出: 6
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

## 进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

## 解析题意

    首先我们看到它进阶中的要求是建立在复杂度为O(n)的基础上再给出分治法求解，
    意味着咱们最基本也要给出复杂度为O(n)的解法，也就意味着在遍历完数组的时候就是功成身退之日，
    那通过暴力枚举出所有和的情况找出最大值就不用再考虑了
    那我们从几个方面开始去考虑
    0.求出最大子序和，意味着这个子序必定是连续的
    1.那我们就可以大胆下结论，该子序存在时前面的元素跟后面的元素必定抛弃
    2.那抛弃的准则是啥呢？没错，就是对我们来说你没有利用价值，意味着我们加上你反而更小了
    3.也就意味着该子序和结束，我们需要开始接下来的最大子序和寻找

# 老规矩上才艺

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let historyMax = nums[0], currentMax = nums[0]
    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(currentMax + nums[i], nums[i])
        historyMax = Math.max(currentMax, historyMax)
    }
    return historyMax
};
```

## 疑惑点解析

为什么比较currentMax + nums[i], nums[i]的值而不是currentMax + nums[i], currentMax的值

    因为我们需要的是连续的子序，所以我们寻找出的值必须可以接着进行下一步的计算
    若是比较currentMax + nums[i], currentMax的值大小则会导致子序不连续的情况

为什么还需要比较 currentMax, historyMax 的值

    这边主要是为了比较历史最大子序和跟当前子序和来寻找新的最大子序和
    例如输入 [-1,-2]时，若不进行historyMax = Math.max(currentMax, historyMax)
    则会输出-2，因为我们没有对子序和-1进行比较

# 课后思考题

题中提到的分治法，大家可以思考一下，其实其在时间复杂度跟空间复杂度上并没有提升，只不过针对任意的子区间也可以灵活求解，故而称之为分治，甚至可以对任意区间内的值进行修改维护

# 总结

**那这道题到底有什么作用呢，我们前端用的到吗？**

当然了，不然我在这里浪费什么时间，我当时在区块链项目中就遇到过一些走势统计问题，当时我没有多想，直接采用暴力求解的方法，可想而知js性能本身就不咋样，即使我将计算进程用worker分发出去也把浏览器干趴下停止响应了老半天，还好当时项目还没有上线，不然我就真的卑微前端在线乞讨了，而这里我只是借用一道抽象出来的算法题来给大家提供一种动态规划解题的思路，当你仔细想想，其实生活当中也是天天打交道，例如股票历史行情分析，企业历年业绩，店面盈亏统计...

