# leetcode 66. 加一
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

## 示例 1:

    输入: [1,2,3]
    输出: [1,2,4]
    解释: 输入数组表示数字 123。

## 示例 2:

    输入: [4,3,2,1]
    输出: [4,3,2,2]
    解释: 输入数组表示数字 4321。

## 解析题意

    简单来说就是，输入的数组其实只是一个非负整数的代表式，例如非负整数为123就输入[1,2,3]，然后将这个非负整数加上1后，输出一个表示这个非负整数的数组表达式。

## 上才艺

    二话不说啪啪啪甩上答案，这不是很简单嘛，简单到我甚至连性能都不想考虑：
    0.先将数组转成字符串，然后加上1会引起隐式转换完成加法运算
    1.再将数值类型转成字符串进行分割转换成字符串数组
    2.最后将数组内字符串转化成数值类型
    3.Done

```
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (Number(digits.join('')) + 1).toString().split('').map(child=>Number(child))
};
```

    提交 -> 报错，解答错误
    好的，不要慌，我们来看一下什么错误

    好的咱们找到了，测试用例 69 / 109 没有通过
    输入：
    [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]
    输出：
    [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,0,0,0]
    预期：
    [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,4]

    我们发现从左往后数，前16位数我们的计算都没有问题，但是为什么后面的值都变成了0，是魔鬼吗

### 错误解析

    我：我错了，我下次再也不随便提交了，现在认错有没有用
    leetcode：没用

    好吧，那我继续弥补

    其实在看到这个测试用例时我已经想到之前在项目中遇到的问题，
    当时是在做区块链项目，大家都知道虚拟币的小数保留位数都是10位，
    在计算过程中经常遇到精度丢失问题，
    这个问题是因为浮点数在运算过程中会转化成二进制运算，
    但是小数用二进制表示时是无穷无尽的，所以需要截断进行计算，
    但是在转化完后就会出现误差，就像经典的0.1 + 0.2 = 0.30000000000000004，
    所以当时为了解决这个问题我先将小数转化成整数再进行计算之后重新转成小数，
    但是又遇到了另一个问题，js中Number遵循IEEE754双精度浮点数，(-2^53 , 2^53)范围内的整数是安全的，
    这意味着整数超过这个部分也会丢失精度，或者说无法正确表示，
    这并不是JS特有的性质，而是IEEE754双精度浮点数就是这么定义的。
    好吧，大概知道是这么回事了，那我们就继续通过已知的知识去解答呗

## 继续上才艺

    既然在（-2^53 , 2^53)范围内的整数是安全的，那咱们就设想一下：
    0.如果咱们把转化后的数字切割成几个安全的整数再进行求解，若有进位则往前一段分割的数进位，直到所有切割完的数都进位结束
    1.既然是分割，咱们的输入已经为我们分割成了一位的若干数组，那岂不是天作之合，直接省去转化过程，开箱即用
    2.根据题意，那咱们就直接从最后一位开始加1，若有进位则往前加1，这样的话时间复杂度就可以控制在O(1) - O(n)之间
    3.Done
```
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function (digits) {
    const len = digits.length
    for (let i = len - 1; i >= 0; i--) {
        if (digits[i] === 9) {
            digits[i] = 0
            if (i === 0) {
                digits.unshift(1)
            }
        } else {
            digits[i]++
            break
        }
    }
    return digits
};
```


